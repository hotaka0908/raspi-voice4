<!DOCTYPE html>
<html lang="ja">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=no">
    <meta name="mobile-web-app-capable" content="yes">
    <meta name="apple-mobile-web-app-status-bar-style" content="black-translucent">
    <title>AI Chat</title>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, sans-serif;
            background: linear-gradient(135deg, #1a1a2e 0%, #16213e 100%);
            min-height: 100vh;
            color: #fff;
            display: flex;
            align-items: center;
            justify-content: center;
        }

        .container {
            display: flex;
            flex-direction: column;
            align-items: center;
            gap: 20px;
        }

        .record-btn {
            width: 120px;
            height: 120px;
            border-radius: 50%;
            border: 5px solid #4ade80;
            background: transparent;
            cursor: pointer;
            transition: all 0.2s;
            display: flex;
            align-items: center;
            justify-content: center;
            -webkit-tap-highlight-color: transparent;
        }

        .record-btn:disabled {
            border-color: #666;
            cursor: not-allowed;
        }

        .record-btn::before {
            content: '';
            width: 60px;
            height: 60px;
            background: #4ade80;
            border-radius: 50%;
            transition: all 0.2s;
        }

        .record-btn:disabled::before {
            background: #666;
        }

        .record-btn.recording {
            border-color: #ef4444;
            animation: pulse-ring 1s infinite;
        }

        .record-btn.recording::before {
            background: #ef4444;
            border-radius: 12px;
            width: 45px;
            height: 45px;
        }

        @keyframes pulse-ring {
            0% { box-shadow: 0 0 0 0 rgba(239, 68, 68, 0.7); }
            100% { box-shadow: 0 0 0 30px rgba(239, 68, 68, 0); }
        }

        .hint {
            font-size: 1rem;
            color: #888;
        }

        .status-text {
            margin-top: 20px;
            font-size: 0.9rem;
            color: #666;
            text-align: center;
            min-height: 24px;
        }

        .status-text.active {
            color: #4ade80;
        }

        .info-panel {
            margin-top: 30px;
            padding: 20px;
            background: rgba(255,255,255,0.05);
            border-radius: 12px;
            max-width: 300px;
            display: none;
            animation: fadeIn 0.3s ease;
        }

        .info-panel.show {
            display: block;
        }

        @keyframes fadeIn {
            from { opacity: 0; transform: translateY(10px); }
            to { opacity: 1; transform: translateY(0); }
        }

        .info-panel h3 {
            font-size: 0.9rem;
            color: #4ade80;
            margin-bottom: 12px;
            text-align: center;
        }

        .info-panel ul {
            list-style: none;
            font-size: 0.85rem;
            color: #aaa;
        }

        .info-panel li {
            padding: 6px 0;
            border-bottom: 1px solid rgba(255,255,255,0.1);
        }

        .info-panel li:last-child {
            border-bottom: none;
        }

        .info-panel li::before {
            content: '•';
            color: #4ade80;
            margin-right: 8px;
        }

        .ai-text {
            font-size: 0.9rem;
            color: #ccc;
            line-height: 1.5;
            text-align: center;
        }
    </style>
</head>
<body>
    <div class="container">
        <button class="record-btn" id="recordBtn" disabled></button>
        <div class="hint">押しながら話す</div>
        <div class="status-text" id="statusText"></div>
        <div class="info-panel" id="infoPanel"></div>
    </div>

    <script src="api-config.js"></script>
    <script>
        // DOM要素
        const recordBtn = document.getElementById('recordBtn');
        const statusText = document.getElementById('statusText');
        const infoPanel = document.getElementById('infoPanel');

        // 状態
        let websocket = null;
        let isConnected = false;
        let isRecording = false;
        let audioContext = null;
        let mediaStream = null;

        // ページ読み込み時に自動接続
        window.addEventListener('load', async () => {
            if (typeof API_CONFIG === 'undefined' || !API_CONFIG.GEMINI_API_KEY || API_CONFIG.GEMINI_API_KEY === 'YOUR_API_KEY_HERE') {
                console.error('APIキーが設定されていません');
                return;
            }
            await connect(API_CONFIG.GEMINI_API_KEY);
        });

        // 接続
        async function connect(apiKey) {
            try {
                // AudioContext初期化
                audioContext = new (window.AudioContext || window.webkitAudioContext)({
                    sampleRate: 24000
                });

                // マイクアクセス
                mediaStream = await navigator.mediaDevices.getUserMedia({
                    audio: {
                        sampleRate: 16000,
                        channelCount: 1,
                        echoCancellation: true,
                        noiseSuppression: true
                    }
                });

                // WebSocket接続
                const wsUrl = `wss://generativelanguage.googleapis.com/ws/google.ai.generativelanguage.v1beta.GenerativeService.BidiGenerateContent?key=${apiKey}`;
                websocket = new WebSocket(wsUrl);

                websocket.onopen = () => {
                    console.log('WebSocket connected');
                    sendSetup();
                };

                websocket.onmessage = (event) => {
                    handleMessage(event.data);
                };

                websocket.onerror = (error) => {
                    console.error('WebSocket error:', error);
                };

                websocket.onclose = (event) => {
                    console.log('WebSocket closed:', event.code);
                    isConnected = false;
                    recordBtn.disabled = true;
                };

            } catch (error) {
                console.error('Connection error:', error);
            }
        }

        // セットアップメッセージ送信
        function sendSetup() {
            const setup = {
                setup: {
                    model: "models/gemini-2.5-flash-native-audio-preview-12-2025",
                    generationConfig: {
                        responseModalities: ["AUDIO"],
                        speechConfig: {
                            voiceConfig: {
                                prebuiltVoiceConfig: {
                                    voiceName: "Kore"
                                }
                            }
                        }
                    },
                    realtimeInputConfig: {
                        automaticActivityDetection: {
                            disabled: true
                        }
                    },
                    systemInstruction: {
                        parts: [{
                            text: "あなたは親切なAIアシスタントです。日本語で簡潔に回答してください。音声での会話なので、1-2文程度の短い応答を心がけてください。\n\nあなたができることは以下の通りです：\n- 質問に答える\n- 雑談・会話\n- アイデアの相談\n- 文章の要約・説明\n- 言語の翻訳\n\n「何ができますか？」と聞かれたら、上記のできることを簡潔に説明してください。"
                        }]
                    }
                }
            };
            websocket.send(JSON.stringify(setup));
        }

        // メッセージ処理
        async function handleMessage(data) {
            try {
                let jsonData;
                if (data instanceof Blob) {
                    jsonData = await data.text();
                } else {
                    jsonData = data;
                }

                if (typeof jsonData === 'string') {
                    const msg = JSON.parse(jsonData);

                    if (msg.setupComplete) {
                        isConnected = true;
                        recordBtn.disabled = false;
                        console.log('Setup complete');
                        return;
                    }

                    if (msg.serverContent) {
                        const content = msg.serverContent;
                        if (content.modelTurn && content.modelTurn.parts) {
                            for (const part of content.modelTurn.parts) {
                                if (part.inlineData && part.inlineData.mimeType.startsWith('audio/')) {
                                    const audioData = base64ToArrayBuffer(part.inlineData.data);
                                    queueAudio(audioData);
                                }
                            }
                        }
                        if (content.turnComplete) {
                            onTurnComplete();
                        }
                    }
                }
            } catch (error) {
                console.error('Message handling error:', error);
            }
        }

        // 録音ボタン
        recordBtn.addEventListener('mousedown', startRecording);
        recordBtn.addEventListener('mouseup', stopRecording);
        recordBtn.addEventListener('mouseleave', stopRecording);
        recordBtn.addEventListener('touchstart', (e) => {
            e.preventDefault();
            startRecording();
        });
        recordBtn.addEventListener('touchend', (e) => {
            e.preventDefault();
            stopRecording();
        });

        // ステータス更新
        function updateStatus(text, active = false) {
            statusText.textContent = text;
            statusText.classList.toggle('active', active);
        }

        // 機能パネル表示
        function showCapabilities() {
            infoPanel.innerHTML = `
                <h3>できること</h3>
                <ul>
                    <li>質問に答える</li>
                    <li>雑談・会話</li>
                    <li>アイデアの相談</li>
                    <li>文章の要約・説明</li>
                    <li>言語の翻訳</li>
                </ul>
            `;
            infoPanel.classList.add('show');
        }

        // 録音開始
        async function startRecording() {
            if (!isConnected || isRecording) return;

            isRecording = true;
            recordBtn.classList.add('recording');
            updateStatus('聞いています...', true);

            if (audioContext.state === 'suspended') {
                await audioContext.resume();
            }

            sendActivityStart();
            audioChunkCount = 0;

            const recordingContext = new (window.AudioContext || window.webkitAudioContext)();
            const source = recordingContext.createMediaStreamSource(mediaStream);
            const processor = recordingContext.createScriptProcessor(4096, 1, 1);

            processor.onaudioprocess = (e) => {
                if (!isRecording) return;

                const inputData = e.inputBuffer.getChannelData(0);
                const ratio = recordingContext.sampleRate / 16000;
                const outputLength = Math.floor(inputData.length / ratio);
                const outputData = new Int16Array(outputLength);

                for (let i = 0; i < outputLength; i++) {
                    const index = Math.floor(i * ratio);
                    outputData[i] = Math.max(-32768, Math.min(32767, inputData[index] * 32768));
                }

                const base64Audio = arrayBufferToBase64(outputData.buffer);
                sendAudio(base64Audio);
            };

            source.connect(processor);
            processor.connect(recordingContext.destination);

            recordBtn._processor = processor;
            recordBtn._source = source;
            recordBtn._recordingContext = recordingContext;
        }

        // 録音停止
        function stopRecording() {
            if (!isRecording) return;

            isRecording = false;
            recordBtn.classList.remove('recording');

            if (recordBtn._processor) {
                recordBtn._processor.disconnect();
                recordBtn._processor = null;
            }
            if (recordBtn._source) {
                recordBtn._source.disconnect();
                recordBtn._source = null;
            }
            if (recordBtn._recordingContext) {
                recordBtn._recordingContext.close();
                recordBtn._recordingContext = null;
            }

            if (audioChunkCount > 0) {
                sendActivityEnd();
                updateStatus('応答中...', true);
            } else {
                updateStatus('');
            }
        }

        // 音声活動開始を通知
        function sendActivityStart() {
            if (!websocket || websocket.readyState !== WebSocket.OPEN) return;
            websocket.send(JSON.stringify({
                realtimeInput: { activityStart: {} }
            }));
        }

        // 音声活動終了を通知
        function sendActivityEnd() {
            if (!websocket || websocket.readyState !== WebSocket.OPEN) return;
            websocket.send(JSON.stringify({
                realtimeInput: { activityEnd: {} }
            }));
        }

        // 音声データ送信
        let audioChunkCount = 0;
        function sendAudio(base64Audio) {
            if (!websocket || websocket.readyState !== WebSocket.OPEN) return;
            audioChunkCount++;
            websocket.send(JSON.stringify({
                realtimeInput: {
                    audio: {
                        mimeType: "audio/pcm;rate=16000",
                        data: base64Audio
                    }
                }
            }));
        }

        // ストリーミング音声再生
        let playbackContext = null;
        let nextPlayTime = 0;

        function queueAudio(pcmData) {
            try {
                if (!playbackContext || playbackContext.state === 'closed') {
                    playbackContext = new (window.AudioContext || window.webkitAudioContext)({
                        sampleRate: 24000
                    });
                    nextPlayTime = 0;
                }

                if (playbackContext.state === 'suspended') {
                    playbackContext.resume();
                }

                const int16Array = new Int16Array(pcmData);
                const float32Array = new Float32Array(int16Array.length);
                for (let i = 0; i < int16Array.length; i++) {
                    float32Array[i] = int16Array[i] / 32768;
                }

                const audioBuffer = playbackContext.createBuffer(1, float32Array.length, 24000);
                audioBuffer.getChannelData(0).set(float32Array);

                const source = playbackContext.createBufferSource();
                source.buffer = audioBuffer;
                source.connect(playbackContext.destination);

                const currentTime = playbackContext.currentTime;
                const startTime = Math.max(currentTime, nextPlayTime);
                source.start(startTime);
                nextPlayTime = startTime + audioBuffer.duration;
            } catch (error) {
                console.error('Audio playback error:', error);
            }
        }

        let isFirstResponse = true;

        function onTurnComplete() {
            nextPlayTime = 0;
            updateStatus('');

            // 最初の応答後に機能一覧を表示
            if (isFirstResponse) {
                isFirstResponse = false;
                setTimeout(() => {
                    showCapabilities();
                }, 500);
            }
        }

        // ユーティリティ関数
        function base64ToArrayBuffer(base64) {
            const binaryString = atob(base64);
            const bytes = new Uint8Array(binaryString.length);
            for (let i = 0; i < binaryString.length; i++) {
                bytes[i] = binaryString.charCodeAt(i);
            }
            return bytes.buffer;
        }

        function arrayBufferToBase64(buffer) {
            const bytes = new Uint8Array(buffer);
            let binary = '';
            for (let i = 0; i < bytes.byteLength; i++) {
                binary += String.fromCharCode(bytes[i]);
            }
            return btoa(binary);
        }
    </script>
</body>
</html>
